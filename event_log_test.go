package mysql_replication_listener

import (
	"bytes"
	"testing"
	"strings"
)

func TestBinlogRotateEvent(t *testing.T) {
	mockHandshake := []byte{
		//length
		0x2C, 0x00, 0x00,
		0x01,
		0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04,
		0x01, 0x00, 0x00, 0x00,
		0x2b, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x20, 0x00,
		0x3f, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6d, 0x79, 0x73, 0x71, 0x6c, 0x2d, 0x62, 0x69, 0x6e, 0x2e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	logRotate := &logRotateEvent{}
	logRotate.eventLogHeader = header
	logRotate.read(pack)

	var expectedTimeStamp uint32 = 0

	if logRotate.Timestamp != expectedTimeStamp {
		t.Fatal(
			"Incorrect timestamp",
			"expected", expectedTimeStamp,
			"got", logRotate.Timestamp,
		)
	}

	if logRotate.EventType != _ROTATE_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _ROTATE_EVENT,
			"got", logRotate.EventType,
		)
	}

	var expectedServerId uint32 = 1

	if logRotate.ServerId != expectedServerId {
		t.Fatal(
			"Incorrect server id",
			"expected", expectedServerId,
			"got", logRotate.ServerId,
		)
	}

	var expectedEvenSize uint32 = 43

	if logRotate.EventSize != expectedEvenSize {
		t.Fatal(
			"Incorrect event size",
			"expected", expectedEvenSize,
			"got", logRotate.EventSize,
		)
	}

	var expectedNextPosition uint32 = 0

	if logRotate.NextPosition != expectedNextPosition {
		t.Fatal(
			"Incorrect next position",
			"expected", expectedNextPosition,
			"got", logRotate.NextPosition,
		)
	}

	var expectedFlags uint16 = 32

	if logRotate.Flags != expectedFlags {
		t.Fatal(
			"Incorrect flags",
			"expected", expectedFlags,
			"got", logRotate.Flags,
		)
	}

	var expectedPosition uint64 = 575

	if logRotate.position != expectedPosition {
		t.Fatal(
			"Incorrect position",
			"expected", expectedPosition,
			"got", logRotate.position,
		)
	}

	expectedBinlogFileName := "mysql-bin.000003"

	if string(logRotate.binlogFileName) != expectedBinlogFileName {
		t.Fatal(
			"Incorrect file name",
			"expected", expectedBinlogFileName,
			"got", string(logRotate.binlogFileName),
		)
	}
}

func TestFormatDescriptionEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x68, 0x00, 0x00,
		0x01,
		//event header
		0x00,
		0x67, 0x6f, 0x66, 0x54,
		0x0f,
		0x01, 0x00, 0x00, 0x00,
		0x67, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00,
		//event
		0x04, 0x00,
		0x35, 0x2e, 0x35, 0x2e, 0x33, 0x38, 0x2d, 0x30, 0x75, 0x62, 0x75, 0x6e, 0x74, 0x75, 0x30, 0x2e, 0x31, 0x34,
		0x2e, 0x30, 0x34, 0x2e, 0x31, 0x2d, 0x6c, 0x6f, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x13,
		0x38, 0x0d, 0x00, 0x08, 0x00, 0x12, 0x00, 0x04, 0x04, 0x04, 0x04, 0x12, 0x00, 0x00, 0x54, 0x00, 0x04, 0x1a,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x02, 0x00,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	formatDesc := &formatDescriptionEvent{}
	formatDesc.eventLogHeader = header
	formatDesc.read(pack)


	if formatDesc.EventType != _FORMAT_DESCRIPTION_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _FORMAT_DESCRIPTION_EVENT,
			"got", formatDesc.EventType,
		)
	}

	var expectedBinlogVersion uint16 = 4

	if formatDesc.binlogVersion != expectedBinlogVersion {
		t.Fatal(
			"Incorrect binlog version",
			"expected", expectedBinlogVersion,
			"got", formatDesc.binlogVersion,
		)
	}

	expectedMysqlServerVersion := "5.5.38-0ubuntu0.14.04.1-log"
	resultVersion := strings.TrimRight(string(formatDesc.mysqlServerVersion), "\x00")
	if resultVersion != expectedMysqlServerVersion {
		t.Fatal(
			"Incorrect mysql version",
			"expected", expectedMysqlServerVersion,
			"got", resultVersion,
		)
	}

}

func TestStartEventV3Event(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x4C, 0x00, 0x00,
		0x01,
		//event header
		0x00,
		0x67, 0x6f, 0x66, 0x54,
		0x01,
		0x01, 0x00, 0x00, 0x00,
		0x67, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00,
		//event
		0x03, 0x00,
		0x35, 0x2e, 0x35, 0x2e, 0x33, 0x38, 0x2d, 0x30, 0x75, 0x62, 0x75, 0x6e, 0x74, 0x75, 0x30, 0x2e, 0x31, 0x34,
		0x2e, 0x30, 0x34, 0x2e, 0x31, 0x2d, 0x6c, 0x6f, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	formatDesc := &startEventV3Event{}
	formatDesc.eventLogHeader = header
	formatDesc.read(pack)


	if formatDesc.EventType != _START_EVENT_V3 {
		t.Fatal(
			"Incorrect event type",
			"expected", _FORMAT_DESCRIPTION_EVENT,
			"got", formatDesc.EventType,
		)
	}

	var expectedBinlogVersion uint16 = 3

	if formatDesc.binlogVersion != expectedBinlogVersion {
		t.Fatal(
			"Incorrect binlog version",
			"expected", expectedBinlogVersion,
			"got", formatDesc.binlogVersion,
		)
	}

	expectedMysqlServerVersion := "5.5.38-0ubuntu0.14.04.1-log"
	resultVersion := strings.TrimRight(string(formatDesc.mysqlServerVersion), "\x00")
	if resultVersion != expectedMysqlServerVersion {
		t.Fatal(
			"Incorrect mysql version",
			"expected", expectedMysqlServerVersion,
			"got", resultVersion,
		)
	}

}

func TestQueryEvent(t *testing.T) {
	mockHandshake := []byte{
		0x45, 0x00, 0x00, 0x01, 0x00, 0xeb, 0x26, 0x7e, 0x54, 0x02,	0x01, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
		0xcf, 0xec, 0x01, 0x00, 0x08, 0x00, 0xa5, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x1a,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x73,
		0x74, 0x64, 0x04, 0x21, 0x00, 0x21, 0x00, 0x08, 0x00, 0x74, 0x65, 0x73, 0x74, 0x00, 0x42, 0x45, 0x47, 0x49,
		0x4e, 0x6D, 0x00, 0x00, 0x02, 0x00, 0xeb, 0x26, 0x7e, 0x54, 0x02, 0x01, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00,
		0x00, 0x3b, 0xed, 0x01, 0x00, 0x00, 0x00, 0xa5, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03,
		0x73, 0x74, 0x64, 0x04, 0x21, 0x00, 0x21, 0x00, 0x08, 0x00, 0x74, 0x65, 0x73, 0x74, 0x00, 0x75, 0x70, 0x64,
		0x61, 0x74, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x30, 0x31, 0x20, 0x73,
		0x65, 0x74, 0x20, 0x64, 0x61, 0x74, 0x61, 0x3d, 0x27, 0x66, 0x66, 0x31, 0x27, 0x20, 0x77, 0x68, 0x65, 0x72,
		0x65, 0x20, 0x69, 0x64, 0x3d, 0x31,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))

	type (
		testCase struct {
			query string
			schema string
			errorCode uint16
			executionTime uint32
		}
	)

	cases := []*testCase {
		&testCase{"BEGIN", "test", 0, 0},
		&testCase{"update test.table01 set data='ff1' where id=1", "test", 0, 0},
	}

	for i, test := range cases {
		t.Log("Test Query event pack", i)
		pack, _ := packReader.readNextPack()

		header := &eventLogHeader{}
		header.read(pack)

		query := &QueryEvent{}
		query.eventLogHeader = header
		query.read(pack, 4)

		if query.Query != test.query {
			t.Fatal(
				"Incorrect query",
				"expected", test.query,
				"got", query.Query,
			)
		}

		if query.Schema != test.schema {
			t.Fatal(
				"Incorrect schema",
				"expected", test.schema,
				"got", query.Schema,
			)
		}

		if query.ErrorCode != test.errorCode {
			t.Fatal(
				"Incorrect error code",
				"expected", test.errorCode,
				"got", query.ErrorCode,
			)
		}

		if query.ExecutionTime != test.executionTime {
			t.Fatal(
				"Incorrect execution time",
				"expected", test.executionTime,
				"got", query.ExecutionTime,
			)
		}
	}


}
