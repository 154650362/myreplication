package mysql_replication_listener

import (
	"bytes"
	"strings"
	"testing"
	"reflect"
)

func TestBinlogRotateEvent(t *testing.T) {
	mockHandshake := []byte{
		//length
		0x2C, 0x00, 0x00,
		0x01,
		0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04,
		0x01, 0x00, 0x00, 0x00,
		0x2b, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x20, 0x00,
		0x3f, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6d, 0x79, 0x73, 0x71, 0x6c, 0x2d, 0x62, 0x69, 0x6e, 0x2e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	logRotate := &logRotateEvent{}
	logRotate.eventLogHeader = header
	logRotate.read(pack)

	var expectedTimeStamp uint32 = 0

	if logRotate.Timestamp != expectedTimeStamp {
		t.Fatal(
			"Incorrect timestamp",
			"expected", expectedTimeStamp,
			"got", logRotate.Timestamp,
		)
	}

	if logRotate.EventType != _ROTATE_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _ROTATE_EVENT,
			"got", logRotate.EventType,
		)
	}

	var expectedServerId uint32 = 1

	if logRotate.ServerId != expectedServerId {
		t.Fatal(
			"Incorrect server id",
			"expected", expectedServerId,
			"got", logRotate.ServerId,
		)
	}

	var expectedEvenSize uint32 = 43

	if logRotate.EventSize != expectedEvenSize {
		t.Fatal(
			"Incorrect event size",
			"expected", expectedEvenSize,
			"got", logRotate.EventSize,
		)
	}

	var expectedNextPosition uint32 = 0

	if logRotate.NextPosition != expectedNextPosition {
		t.Fatal(
			"Incorrect next position",
			"expected", expectedNextPosition,
			"got", logRotate.NextPosition,
		)
	}

	var expectedFlags uint16 = 32

	if logRotate.Flags != expectedFlags {
		t.Fatal(
			"Incorrect flags",
			"expected", expectedFlags,
			"got", logRotate.Flags,
		)
	}

	var expectedPosition uint64 = 575

	if logRotate.position != expectedPosition {
		t.Fatal(
			"Incorrect position",
			"expected", expectedPosition,
			"got", logRotate.position,
		)
	}

	expectedBinlogFileName := "mysql-bin.000003"

	if string(logRotate.binlogFileName) != expectedBinlogFileName {
		t.Fatal(
			"Incorrect file name",
			"expected", expectedBinlogFileName,
			"got", string(logRotate.binlogFileName),
		)
	}
}

func TestFormatDescriptionEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x68, 0x00, 0x00,
		0x01,
		//event header
		0x00,
		0x67, 0x6f, 0x66, 0x54,
		0x0f,
		0x01, 0x00, 0x00, 0x00,
		0x67, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00,
		//event
		0x04, 0x00,
		0x35, 0x2e, 0x35, 0x2e, 0x33, 0x38, 0x2d, 0x30, 0x75, 0x62, 0x75, 0x6e, 0x74, 0x75, 0x30, 0x2e, 0x31, 0x34,
		0x2e, 0x30, 0x34, 0x2e, 0x31, 0x2d, 0x6c, 0x6f, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x13,
		0x38, 0x0d, 0x00, 0x08, 0x00, 0x12, 0x00, 0x04, 0x04, 0x04, 0x04, 0x12, 0x00, 0x00, 0x54, 0x00, 0x04, 0x1a,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x02, 0x00,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	formatDesc := &formatDescriptionEvent{}
	formatDesc.eventLogHeader = header
	formatDesc.read(pack)

	if formatDesc.EventType != _FORMAT_DESCRIPTION_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _FORMAT_DESCRIPTION_EVENT,
			"got", formatDesc.EventType,
		)
	}

	var expectedBinlogVersion uint16 = 4

	if formatDesc.binlogVersion != expectedBinlogVersion {
		t.Fatal(
			"Incorrect binlog version",
			"expected", expectedBinlogVersion,
			"got", formatDesc.binlogVersion,
		)
	}

	expectedMysqlServerVersion := "5.5.38-0ubuntu0.14.04.1-log"
	resultVersion := strings.TrimRight(string(formatDesc.mysqlServerVersion), "\x00")
	if resultVersion != expectedMysqlServerVersion {
		t.Fatal(
			"Incorrect mysql version",
			"expected", expectedMysqlServerVersion,
			"got", resultVersion,
		)
	}

}

func TestStartEventV3Event(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x4C, 0x00, 0x00,
		0x01,
		//event header
		0x00,
		0x67, 0x6f, 0x66, 0x54,
		0x01,
		0x01, 0x00, 0x00, 0x00,
		0x67, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00,
		//event
		0x03, 0x00,
		0x35, 0x2e, 0x35, 0x2e, 0x33, 0x38, 0x2d, 0x30, 0x75, 0x62, 0x75, 0x6e, 0x74, 0x75, 0x30, 0x2e, 0x31, 0x34,
		0x2e, 0x30, 0x34, 0x2e, 0x31, 0x2d, 0x6c, 0x6f, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	formatDesc := &startEventV3Event{}
	formatDesc.eventLogHeader = header
	formatDesc.read(pack)

	if formatDesc.EventType != _START_EVENT_V3 {
		t.Fatal(
			"Incorrect event type",
			"expected", _FORMAT_DESCRIPTION_EVENT,
			"got", formatDesc.EventType,
		)
	}

	var expectedBinlogVersion uint16 = 3

	if formatDesc.binlogVersion != expectedBinlogVersion {
		t.Fatal(
			"Incorrect binlog version",
			"expected", expectedBinlogVersion,
			"got", formatDesc.binlogVersion,
		)
	}

	expectedMysqlServerVersion := "5.5.38-0ubuntu0.14.04.1-log"
	resultVersion := strings.TrimRight(string(formatDesc.mysqlServerVersion), "\x00")
	if resultVersion != expectedMysqlServerVersion {
		t.Fatal(
			"Incorrect mysql version",
			"expected", expectedMysqlServerVersion,
			"got", resultVersion,
		)
	}

}

func TestQueryEvent(t *testing.T) {
	mockHandshake := []byte{
		0x45, 0x00, 0x00, 0x01, 0x00, 0xeb, 0x26, 0x7e, 0x54, 0x02, 0x01, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
		0xcf, 0xec, 0x01, 0x00, 0x08, 0x00, 0xa5, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x1a,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x73,
		0x74, 0x64, 0x04, 0x21, 0x00, 0x21, 0x00, 0x08, 0x00, 0x74, 0x65, 0x73, 0x74, 0x00, 0x42, 0x45, 0x47, 0x49,
		0x4e, 0x6D, 0x00, 0x00, 0x02, 0x00, 0xeb, 0x26, 0x7e, 0x54, 0x02, 0x01, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00,
		0x00, 0x3b, 0xed, 0x01, 0x00, 0x00, 0x00, 0xa5, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03,
		0x73, 0x74, 0x64, 0x04, 0x21, 0x00, 0x21, 0x00, 0x08, 0x00, 0x74, 0x65, 0x73, 0x74, 0x00, 0x75, 0x70, 0x64,
		0x61, 0x74, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x30, 0x31, 0x20, 0x73,
		0x65, 0x74, 0x20, 0x64, 0x61, 0x74, 0x61, 0x3d, 0x27, 0x66, 0x66, 0x31, 0x27, 0x20, 0x77, 0x68, 0x65, 0x72,
		0x65, 0x20, 0x69, 0x64, 0x3d, 0x31,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))

	type (
		testCase struct {
			query         string
			schema        string
			errorCode     uint16
			executionTime uint32
		}
	)

	cases := []*testCase{
		&testCase{"BEGIN", "test", 0, 0},
		&testCase{"update test.table01 set data='ff1' where id=1", "test", 0, 0},
	}

	for i, test := range cases {
		t.Log("Test Query event pack", i)
		pack, _ := packReader.readNextPack()

		header := &eventLogHeader{}
		header.read(pack)

		query := &QueryEvent{
			eventLogHeader: header,
			binLogVersion:  4,
		}
		query.read(pack)

		if query.Query != test.query {
			t.Fatal(
				"Incorrect query",
				"expected", test.query,
				"got", query.Query,
			)
		}

		if query.Schema != test.schema {
			t.Fatal(
				"Incorrect schema",
				"expected", test.schema,
				"got", query.Schema,
			)
		}

		if query.ErrorCode != test.errorCode {
			t.Fatal(
				"Incorrect error code",
				"expected", test.errorCode,
				"got", query.ErrorCode,
			)
		}

		if query.ExecutionTime != test.executionTime {
			t.Fatal(
				"Incorrect execution time",
				"expected", test.executionTime,
				"got", query.ExecutionTime,
			)
		}
	}
}

func TestXidEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x1C, 0x00, 0x00,
		0x01,
		//event header
		0x00, 0x96, 0x34, 0x7e, 0x54, 0x10, 0x01, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0xec, 0xee, 0x01, 0x00,
		0x00, 0x00, 0x08, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	xid := &XidEvent{}
	xid.eventLogHeader = header
	xid.read(pack)

	if xid.EventType != _XID_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _XID_EVENT,
			"got", xid.EventType,
		)
	}

	var expectedTransactionId uint64 = 29960

	if xid.TransactionId != expectedTransactionId {
		t.Fatal(
			"Incorrect transaction id",
			"expected", expectedTransactionId,
			"got", xid.TransactionId,
		)
	}

}

func TestIntVarEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x1D, 0x00, 0x00,
		0x01,
		//event header
		0x00, 0x65, 0x6f, 0x7f, 0x54, 0x05, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x6a, 0xf2, 0x01, 0x00,
		0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	intVar := &IntVarEvent{}
	intVar.eventLogHeader = header
	intVar.read(pack)

	if intVar.EventType != _INTVAR_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _INTVAR_EVENT,
			"got", intVar.EventType,
		)
	}

	var expectedValue uint64 = 1

	if intVar.Value != expectedValue {
		t.Fatal(
			"Incorrect value",
			"expected", expectedValue,
			"got", intVar.Value,
		)
	}

	if intVar.Type != INSERT_ID_EVENT {
		t.Fatal(
			"Incorrect type",
			"expected", INSERT_ID_EVENT,
			"got", intVar.Type,
		)
	}
}

func TestBeginLoadQueryEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x28, 0x00, 0x00,
		0x01,
		//event header
		0x00, 0xce, 0x7c, 0x7f, 0x54, 0x11, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0xa3, 0xf7, 0x01, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x35, 0x2c, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x0a, 0x36, 0x2c, 0x77, 0x6f,
		0x72, 0x6c, 0x64, 0x0a,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	beginEvent := &BeginLoadQueryEvent{}
	beginEvent.eventLogHeader = header
	beginEvent.read(pack)

	if beginEvent.EventType != _BEGIN_LOAD_QUERY_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _BEGIN_LOAD_QUERY_EVENT,
			"got", beginEvent.EventType,
		)
	}

	var expectedFileId uint32 = 1

	if beginEvent.FileId != expectedFileId {
		t.Fatal(
			"Incorrect file id",
			"expected", expectedFileId,
			"got", beginEvent.FileId,
		)
	}

	expectedBlockData := "5,hello\n6,world\n"

	if beginEvent.BlockData != expectedBlockData {
		t.Fatal(
			"Incorrect block data",
			"expected", expectedBlockData,
			"got", beginEvent.BlockData,
		)
	}
}

func TestExecuteLoadQueryEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0xD9, 0x00, 0x00,
		0x01,
		//event header
		0x00, 0xce, 0x7c, 0x7f, 0x54, 0x12, 0x01, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x00, 0x7b, 0xf8, 0x01, 0x00,
		0x00, 0x00, 0xd8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x1a, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x09, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x73, 0x74, 0x64, 0x04, 0x21, 0x00, 0x21, 0x00, 0x08, 0x00,
		0x74, 0x65, 0x73, 0x74, 0x00, 0x4c, 0x4f, 0x41, 0x44, 0x20, 0x44, 0x41, 0x54, 0x41, 0x20, 0x49, 0x4e, 0x46,
		0x49, 0x4c, 0x45, 0x20, 0x27, 0x64, 0x61, 0x74, 0x61, 0x27, 0x20, 0x49, 0x4e, 0x54, 0x4f, 0x20, 0x54, 0x41,
		0x42, 0x4c, 0x45, 0x20, 0x60, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x30, 0x31, 0x60, 0x20, 0x46, 0x49, 0x45, 0x4c,
		0x44, 0x53, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x54, 0x45, 0x44, 0x20, 0x42, 0x59, 0x20, 0x27,
		0x2c, 0x27, 0x20, 0x45, 0x4e, 0x43, 0x4c, 0x4f, 0x53, 0x45, 0x44, 0x20, 0x42, 0x59, 0x20, 0x27, 0x27, 0x20,
		0x45, 0x53, 0x43, 0x41, 0x50, 0x45, 0x44, 0x20, 0x42, 0x59, 0x20, 0x27, 0x5c, 0x5c, 0x27, 0x20, 0x4c, 0x49,
		0x4e, 0x45, 0x53, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x54, 0x45, 0x44, 0x20, 0x42, 0x59, 0x20,
		0x27, 0x5c, 0x6e, 0x27, 0x20, 0x28, 0x60, 0x69, 0x64, 0x60, 0x2c, 0x20, 0x60, 0x64, 0x61, 0x74, 0x61, 0x60,
		0x29,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	executeLoad := &ExecuteLoadQueryEvent{}
	executeLoad.eventLogHeader = header
	executeLoad.read(pack)

	if executeLoad.EventType != _EXECUTE_LOAD_QUERY_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _EXECUTE_LOAD_QUERY_EVENT,
			"got", executeLoad.EventType,
		)
	}

	expectedSchema := "test"

	if executeLoad.Schema != expectedSchema {
		t.Fatal(
			"Incorrect schema",
			"expected", expectedSchema,
			"got", executeLoad.Schema,
		)
	}

	var expectedErrorCode uint16 = 0

	if executeLoad.ErrorCode != expectedErrorCode {
		t.Fatal(
			"Incorrect error code",
			"expected", expectedErrorCode,
			"got", executeLoad.ErrorCode,
		)
	}

	var expectedExecutionTime uint32 = 0

	if executeLoad.ExecutionTime != expectedExecutionTime {
		t.Fatal(
			"Incorrect execution time",
			"expected", expectedExecutionTime,
			"got", executeLoad.ExecutionTime,
		)
	}

	expectedQuery := "LOAD DATA INFILE 'data' INTO TABLE `table01` FIELDS TERMINATED BY ',' ENCLOSED BY '' "
	expectedQuery += "ESCAPED BY '\\\\' LINES TERMINATED BY '\\n' (`id`, `data`)"

	if executeLoad.Query != expectedQuery {
		t.Fatal(
			"Incorrect query",
			"expected", expectedQuery,
			"got", executeLoad.Query,
		)
	}
}

func TestUserVarEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x2F, 0x00, 0x00,
		0x01,
		//event header
		0x00, 0x47, 0xc0, 0x80, 0x54, 0x0e, 0x01, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x4c, 0xfd, 0x01, 0x00,
		0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x76, 0x61, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x21, 0x00,
		0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x73, 0x73, 0x73, 0x73, 0x73,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	userVar := &UserVarEvent{}
	userVar.eventLogHeader = header
	userVar.read(pack)

	if userVar.EventType != _USER_VAR_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _USER_VAR_EVENT,
			"got", userVar.EventType,
		)
	}

	expectedName := "var_name"

	if userVar.Name != expectedName {
		t.Fatal(
			"Incorrect variable name",
			"expected", expectedName,
			"got", userVar.Name,
		)
	}

	expectedIsNil := false

	if userVar.IsNil != expectedIsNil {
		t.Fatal(
			"Incorrect is_null",
			"expected", expectedIsNil,
			"got", userVar.IsNil,
		)
	}

	expectedValue := "sssss"

	if userVar.Value != expectedValue {
		t.Fatal(
			"Incorrect value",
			"expected", expectedValue,
			"got", userVar.Value,
		)
	}
}

func TestRandEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x24, 0x00, 0x00,
		0x01,
		//event header
		0x00, 0xc6, 0xce, 0x80, 0x54, 0x0d, 0x01, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x9b, 0x02, 0x00, 0x00,
		0x00, 0x00, 0xbf, 0xfa, 0x4e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x76, 0x1c, 0x04, 0x3c, 0x00, 0x00, 0x00, 0x00,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	rand := &RandEvent{}
	rand.eventLogHeader = header
	rand.read(pack)

	if rand.EventType != _RAND_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _RAND_EVENT,
			"got", rand.EventType,
		)
	}

	var expectedSeed1 uint64 = 508492479
	var expectedSeed2 uint64 = 1006902390

	if rand.Seed1 != expectedSeed1 {
		t.Fatal(
			"Incorrect seed1",
			"expected", expectedSeed1,
			"got", rand.Seed1,
		)
	}

	if rand.Seed2 != expectedSeed2 {
		t.Fatal(
			"Incorrect seed2",
			"expected", expectedSeed2,
			"got", rand.Seed2,
		)
	}
}

func TestTableMapEvent(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0x49, 0x00, 0x00,
		0x01,
		//event header
		0x00,
		0x5d, 0xff, 0x86, 0x54,
		0x13,
		0x01, 0x00, 0x00, 0x00,
		0x48, 0x00, 0x00, 0x00,
		0x34, 0x06, 0x00, 0x00,
		0x00, 0x00,
		//body
		//table id
		0x2c, 0x00, 0x00, 0x00, 0x00, 0x00,
		//flags
		0x01, 0x00,
		//schema length
		0x04,
		//schema name "test"
		0x74, 0x65, 0x73, 0x74,
		//filler
		0x00,
		//table name length
		0x05,
		//table name "types"
		0x74, 0x79, 0x70, 0x65, 0x73,
		//filler
		0x00,
		//column count
		0x13,
		//column count def
		0x03, 0x01, 0x01, 0x02, 0x02, 0x09, 0x09, 0x03, 0x03, 0x03, 0x03, 0x08, 0x08, 0xf6, 0xf6, 0x05, 0x05, 0x04, 0x04,
		//meta info length
		0x08,
		//meta info
		0x0a, 0x00, 0x0a, 0x00, 0x08, 0x08, 0x04, 0x04,
		//bit mask
		0x6e, 0xfb, 0x07,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	table := &TableMapEvent{}
	table.eventLogHeader = header
	table.read(pack)

	if table.EventType != _TABLE_MAP_EVENT {
		t.Fatal(
			"Incorrect event type",
			"expected", _TABLE_MAP_EVENT,
			"got", table.EventType,
		)
	}

	expectedSchema := "test"
	if table.SchemaName != expectedSchema {
		t.Fatal(
			"Incorrect schema name",
			"expected", expectedSchema,
			"got", table.SchemaName,
		)
	}

	expectedTable := "types"
	if table.TableName != expectedTable {
		t.Fatal(
			"Incorrect table name",
			"expected", expectedTable,
			"got", table.TableName,
		)
	}

	expectedColumnCount := 19
	if len(table.Columns) != expectedColumnCount {
		t.Fatal(
			"Incorrect column count",
			"expected", expectedColumnCount,
			"got", len(table.Columns),
		)
	}

	type (
		TableMapEventTest struct {
			expectedType   byte
			expectedIsNull bool
			expectedMetaInfo       []byte
		}
	)

	testsCases := []*TableMapEventTest{
		&TableMapEventTest{_MYSQL_TYPE_LONG, false, []byte{}},             // `id` int(11) NOT NULL AUTO_INCREMENT,
		&TableMapEventTest{_MYSQL_TYPE_TINY, true, []byte{}},              // `i1` tinyint(4) DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_TINY, true, []byte{}},              // `i2` tinyint(3) unsigned DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_SHORT, true, []byte{}},             // `i3` smallint(6) DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_SHORT, false, []byte{}},            // `i4` smallint(5) unsigned NOT NULL,
		&TableMapEventTest{_MYSQL_TYPE_INT24, true, []byte{}},            // `i5` mediumint(9) DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_INT24, true, []byte{}},            // `i6` mediumint(8) unsigned DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_LONG, false, []byte{}},             // `i7` int(11) NOT NULL,
		&TableMapEventTest{_MYSQL_TYPE_LONG, true, []byte{}},              // `i8` int(10) unsigned DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_LONG, true, []byte{}},              // `i9` int(11) DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_LONG, false, []byte{}},             // `1i0` int(10) unsigned NOT NULL,
		&TableMapEventTest{_MYSQL_TYPE_LONGLONG, true, []byte{}},          // `1i1` bigint(20) DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_LONGLONG, true, []byte{}},          // `1i2` bigint(20) unsigned DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_NEWDECIMAL, true, []byte{0x0a, 0x00}}, // `1i3` decimal(10,0) DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_NEWDECIMAL, true, []byte{0x0a, 0x00}}, // `1i4` decimal(10,0) unsigned DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_DOUBLE, true, []byte{0x08}},        // `1i5` double DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_DOUBLE, true, []byte{0x08}},        // `1i6` double unsigned DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_FLOAT, true, []byte{0x04}},         // `1i7` float DEFAULT NULL,
		&TableMapEventTest{_MYSQL_TYPE_FLOAT, true, []byte{0x04}},         // `1i8` float unsigned DEFAULT NULL,
	}

	for i, testCase := range testsCases {
		testColumn := table.Columns[i]

		if testColumn.Type != testCase.expectedType {
			t.Fatal(
				"Incorrect columnt type with index", i,
				"expected", testCase.expectedType,
				"got", testColumn.Type,
			)
		}

		if testColumn.Null != testCase.expectedIsNull {
			t.Fatal(
				"Incorrect null flag with index", i,
				"expected", testCase.expectedIsNull,
				"got", testColumn.Null,
			)
		}

		if !reflect.DeepEqual(testColumn.MetaInfo, testCase.expectedMetaInfo) {
			t.Fatal(
				"Incorrect meta info",
				"expected", testCase.expectedMetaInfo,
				"got", testColumn.MetaInfo,
			)
		}
	}
}

func TestUpdateRowsEventV1(t *testing.T) {
	mockHandshake := []byte{
		//pack header
		0xCD, 0x00, 0x00,
		0x01,
		//event header
		0x00,
		0x3a, 0x02, 0x87, 0x54,
		0x18,
		0x01, 0x00, 0x00, 0x00,
		0xcc, 0x00, 0x00, 0x00,
		0x64, 0x09, 0x00, 0x00,
		0x00, 0x00,
		//body
		//table id
		0x2d, 0x00, 0x00, 0x00, 0x00, 0x00,
		//flags
		0x01, 0x00,
		//columns count = 19
		0x13,
		//bitmap 1
		0xff, 0xff, 0xff,
		//bitmap 2
		0xff, 0xff, 0xff,
		//bull bitmap
		0x00, 0x00, 0xf8,

		0x01, 0x00, 0x00, 0x00,
		0x01,
		0x01,
		0x01, 0x00,
		0x01, 0x00,
		0x01, 0x00, 0x00,
		0x01, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		0x80, 0x00, 0x00, 0x00, 0x01,
		0x80, 0x00, 0x00, 0x00, 0x01,

		0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		0xf0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xf0, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00,

		0x80, 0x3f, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40,
	}

	packReader := newPackReader(bytes.NewBuffer(mockHandshake))
	pack, _ := packReader.readNextPack()

	header := &eventLogHeader{}
	header.read(pack)

	update := &UpdateRowsEvent{}
	update.setVersion(byte(1))
	update.setPostHeaderLength(byte(8))
	update.eventLogHeader = header
	update.read(pack)

	if update.EventType != _UPDATE_ROWS_EVENTv1 {
		t.Fatal(
			"Incorrect event type",
			"expected", _UPDATE_ROWS_EVENTv1,
			"got", update.EventType,
		)
	}

}
